// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.3
// source: proto/replication.proto

package razpravljalnica

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ReplicationService_ReplicateUser_FullMethodName     = "/razpravljalnica.ReplicationService/ReplicateUser"
	ReplicationService_ReplicateTopic_FullMethodName    = "/razpravljalnica.ReplicationService/ReplicateTopic"
	ReplicationService_ReplicateMessage_FullMethodName  = "/razpravljalnica.ReplicationService/ReplicateMessage"
	ReplicationService_ReplicateLike_FullMethodName     = "/razpravljalnica.ReplicationService/ReplicateLike"
	ReplicationService_UpdateSuccessor_FullMethodName   = "/razpravljalnica.ReplicationService/UpdateSuccessor"
	ReplicationService_UpdatePredecessor_FullMethodName = "/razpravljalnica.ReplicationService/UpdatePredecessor"
	ReplicationService_Ping_FullMethodName              = "/razpravljalnica.ReplicationService/Ping"
	ReplicationService_GetFullState_FullMethodName      = "/razpravljalnica.ReplicationService/GetFullState"
	ReplicationService_SyncState_FullMethodName         = "/razpravljalnica.ReplicationService/SyncState"
)

// ReplicationServiceClient is the client API for ReplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service za komunikacijo med vozlišči v verigi
type ReplicationServiceClient interface {
	// Repliciraj novo uporabnika
	ReplicateUser(ctx context.Context, in *ReplicateUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Repliciraj novo temo
	ReplicateTopic(ctx context.Context, in *ReplicateTopicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Repliciraj novo sporočilo
	ReplicateMessage(ctx context.Context, in *ReplicateMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Repliciraj like
	ReplicateLike(ctx context.Context, in *ReplicateLikeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Posodobi naslednika v verigi
	UpdateSuccessor(ctx context.Context, in *UpdateSuccessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Posodobi predhodnika v verigi
	UpdatePredecessor(ctx context.Context, in *UpdatePredecessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Health check / ping
	Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error)
	// Pridobi trenutno stanje (za sinhronizacijo novega vozlišča)
	GetFullState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FullStateResponse, error)
	// Sinhroniziraj stanje (receiver aplicira celotno stanje)
	SyncState(ctx context.Context, in *FullStateResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type replicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationServiceClient(cc grpc.ClientConnInterface) ReplicationServiceClient {
	return &replicationServiceClient{cc}
}

func (c *replicationServiceClient) ReplicateUser(ctx context.Context, in *ReplicateUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_ReplicateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) ReplicateTopic(ctx context.Context, in *ReplicateTopicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_ReplicateTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) ReplicateMessage(ctx context.Context, in *ReplicateMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_ReplicateMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) ReplicateLike(ctx context.Context, in *ReplicateLikeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_ReplicateLike_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) UpdateSuccessor(ctx context.Context, in *UpdateSuccessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_UpdateSuccessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) UpdatePredecessor(ctx context.Context, in *UpdatePredecessorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_UpdatePredecessor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) Ping(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, ReplicationService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) GetFullState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*FullStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FullStateResponse)
	err := c.cc.Invoke(ctx, ReplicationService_GetFullState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) SyncState(ctx context.Context, in *FullStateResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ReplicationService_SyncState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplicationServiceServer is the server API for ReplicationService service.
// All implementations must embed UnimplementedReplicationServiceServer
// for forward compatibility.
//
// Service za komunikacijo med vozlišči v verigi
type ReplicationServiceServer interface {
	// Repliciraj novo uporabnika
	ReplicateUser(context.Context, *ReplicateUserRequest) (*emptypb.Empty, error)
	// Repliciraj novo temo
	ReplicateTopic(context.Context, *ReplicateTopicRequest) (*emptypb.Empty, error)
	// Repliciraj novo sporočilo
	ReplicateMessage(context.Context, *ReplicateMessageRequest) (*emptypb.Empty, error)
	// Repliciraj like
	ReplicateLike(context.Context, *ReplicateLikeRequest) (*emptypb.Empty, error)
	// Posodobi naslednika v verigi
	UpdateSuccessor(context.Context, *UpdateSuccessorRequest) (*emptypb.Empty, error)
	// Posodobi predhodnika v verigi
	UpdatePredecessor(context.Context, *UpdatePredecessorRequest) (*emptypb.Empty, error)
	// Health check / ping
	Ping(context.Context, *emptypb.Empty) (*PingResponse, error)
	// Pridobi trenutno stanje (za sinhronizacijo novega vozlišča)
	GetFullState(context.Context, *emptypb.Empty) (*FullStateResponse, error)
	// Sinhroniziraj stanje (receiver aplicira celotno stanje)
	SyncState(context.Context, *FullStateResponse) (*emptypb.Empty, error)
	mustEmbedUnimplementedReplicationServiceServer()
}

// UnimplementedReplicationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplicationServiceServer struct{}

func (UnimplementedReplicationServiceServer) ReplicateUser(context.Context, *ReplicateUserRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplicateUser not implemented")
}
func (UnimplementedReplicationServiceServer) ReplicateTopic(context.Context, *ReplicateTopicRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplicateTopic not implemented")
}
func (UnimplementedReplicationServiceServer) ReplicateMessage(context.Context, *ReplicateMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplicateMessage not implemented")
}
func (UnimplementedReplicationServiceServer) ReplicateLike(context.Context, *ReplicateLikeRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReplicateLike not implemented")
}
func (UnimplementedReplicationServiceServer) UpdateSuccessor(context.Context, *UpdateSuccessorRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSuccessor not implemented")
}
func (UnimplementedReplicationServiceServer) UpdatePredecessor(context.Context, *UpdatePredecessorRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePredecessor not implemented")
}
func (UnimplementedReplicationServiceServer) Ping(context.Context, *emptypb.Empty) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedReplicationServiceServer) GetFullState(context.Context, *emptypb.Empty) (*FullStateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFullState not implemented")
}
func (UnimplementedReplicationServiceServer) SyncState(context.Context, *FullStateResponse) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncState not implemented")
}
func (UnimplementedReplicationServiceServer) mustEmbedUnimplementedReplicationServiceServer() {}
func (UnimplementedReplicationServiceServer) testEmbeddedByValue()                            {}

// UnsafeReplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationServiceServer will
// result in compilation errors.
type UnsafeReplicationServiceServer interface {
	mustEmbedUnimplementedReplicationServiceServer()
}

func RegisterReplicationServiceServer(s grpc.ServiceRegistrar, srv ReplicationServiceServer) {
	// If the following call panics, it indicates UnimplementedReplicationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplicationService_ServiceDesc, srv)
}

func _ReplicationService_ReplicateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).ReplicateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_ReplicateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).ReplicateUser(ctx, req.(*ReplicateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_ReplicateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).ReplicateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_ReplicateTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).ReplicateTopic(ctx, req.(*ReplicateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_ReplicateMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).ReplicateMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_ReplicateMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).ReplicateMessage(ctx, req.(*ReplicateMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_ReplicateLike_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicateLikeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).ReplicateLike(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_ReplicateLike_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).ReplicateLike(ctx, req.(*ReplicateLikeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_UpdateSuccessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSuccessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).UpdateSuccessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_UpdateSuccessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).UpdateSuccessor(ctx, req.(*UpdateSuccessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_UpdatePredecessor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePredecessorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).UpdatePredecessor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_UpdatePredecessor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).UpdatePredecessor(ctx, req.(*UpdatePredecessorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).Ping(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_GetFullState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).GetFullState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_GetFullState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).GetFullState(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_SyncState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FullStateResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).SyncState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_SyncState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).SyncState(ctx, req.(*FullStateResponse))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplicationService_ServiceDesc is the grpc.ServiceDesc for ReplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "razpravljalnica.ReplicationService",
	HandlerType: (*ReplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReplicateUser",
			Handler:    _ReplicationService_ReplicateUser_Handler,
		},
		{
			MethodName: "ReplicateTopic",
			Handler:    _ReplicationService_ReplicateTopic_Handler,
		},
		{
			MethodName: "ReplicateMessage",
			Handler:    _ReplicationService_ReplicateMessage_Handler,
		},
		{
			MethodName: "ReplicateLike",
			Handler:    _ReplicationService_ReplicateLike_Handler,
		},
		{
			MethodName: "UpdateSuccessor",
			Handler:    _ReplicationService_UpdateSuccessor_Handler,
		},
		{
			MethodName: "UpdatePredecessor",
			Handler:    _ReplicationService_UpdatePredecessor_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _ReplicationService_Ping_Handler,
		},
		{
			MethodName: "GetFullState",
			Handler:    _ReplicationService_GetFullState_Handler,
		},
		{
			MethodName: "SyncState",
			Handler:    _ReplicationService_SyncState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/replication.proto",
}

const (
	NodeManagement_RegisterNode_FullMethodName = "/razpravljalnica.NodeManagement/RegisterNode"
	NodeManagement_Heartbeat_FullMethodName    = "/razpravljalnica.NodeManagement/Heartbeat"
	NodeManagement_GetChainInfo_FullMethodName = "/razpravljalnica.NodeManagement/GetChainInfo"
)

// NodeManagementClient is the client API for NodeManagement service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service za upravljanje vozlišč (control plane ↔ nodes)
type NodeManagementClient interface {
	// Registriraj vozlišče v kontrolni ravnini
	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
	// Heartbeat od vozlišča
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Pridobi informacije o verigi
	GetChainInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChainInfoResponse, error)
}

type nodeManagementClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeManagementClient(cc grpc.ClientConnInterface) NodeManagementClient {
	return &nodeManagementClient{cc}
}

func (c *nodeManagementClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterNodeResponse)
	err := c.cc.Invoke(ctx, NodeManagement_RegisterNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeManagementClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NodeManagement_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeManagementClient) GetChainInfo(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChainInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChainInfoResponse)
	err := c.cc.Invoke(ctx, NodeManagement_GetChainInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeManagementServer is the server API for NodeManagement service.
// All implementations must embed UnimplementedNodeManagementServer
// for forward compatibility.
//
// Service za upravljanje vozlišč (control plane ↔ nodes)
type NodeManagementServer interface {
	// Registriraj vozlišče v kontrolni ravnini
	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
	// Heartbeat od vozlišča
	Heartbeat(context.Context, *HeartbeatRequest) (*emptypb.Empty, error)
	// Pridobi informacije o verigi
	GetChainInfo(context.Context, *emptypb.Empty) (*ChainInfoResponse, error)
	mustEmbedUnimplementedNodeManagementServer()
}

// UnimplementedNodeManagementServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodeManagementServer struct{}

func (UnimplementedNodeManagementServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterNode not implemented")
}
func (UnimplementedNodeManagementServer) Heartbeat(context.Context, *HeartbeatRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedNodeManagementServer) GetChainInfo(context.Context, *emptypb.Empty) (*ChainInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChainInfo not implemented")
}
func (UnimplementedNodeManagementServer) mustEmbedUnimplementedNodeManagementServer() {}
func (UnimplementedNodeManagementServer) testEmbeddedByValue()                        {}

// UnsafeNodeManagementServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeManagementServer will
// result in compilation errors.
type UnsafeNodeManagementServer interface {
	mustEmbedUnimplementedNodeManagementServer()
}

func RegisterNodeManagementServer(s grpc.ServiceRegistrar, srv NodeManagementServer) {
	// If the following call panics, it indicates UnimplementedNodeManagementServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodeManagement_ServiceDesc, srv)
}

func _NodeManagement_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeManagementServer).RegisterNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeManagement_RegisterNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeManagementServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeManagement_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeManagementServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeManagement_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeManagementServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeManagement_GetChainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeManagementServer).GetChainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeManagement_GetChainInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeManagementServer).GetChainInfo(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeManagement_ServiceDesc is the grpc.ServiceDesc for NodeManagement service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeManagement_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "razpravljalnica.NodeManagement",
	HandlerType: (*NodeManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterNode",
			Handler:    _NodeManagement_RegisterNode_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _NodeManagement_Heartbeat_Handler,
		},
		{
			MethodName: "GetChainInfo",
			Handler:    _NodeManagement_GetChainInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/replication.proto",
}
